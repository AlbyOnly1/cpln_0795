# Introduction to GIS with R - The Tidyverse and sf
# CPLN 0795, 2024

# We are going to do almost the exact same routines that we did in classes 2-3 using ArcGIS, 
# except we will do it in R.

# First we toy around with code really simply to see how it executes.

# This is some basic R stuff

# I can do some stuff in the console by executing code

print("hello world")

# I can also make some new objects in my environment

string_object <- "derp"

numeric_object <- 5

vector_object <- c("schwarber", "turner", "harper", "bohm", "realmuto", "castellanos", "stott", "sosa", "rojas")

# To get started we are going to load libraries that we will need to work with more complex data like
# spatial objects and data-frames (aka spreadsheet type things)

library(tidyverse)
library(sf)
library(tigris)

# Now let's load the data 

# Load a csv

phila_tracts <- read.csv("https://raw.githubusercontent.com/mafichman/cpln_0795/main/data/philadelphia_tracts_2020.csv")
  
# What do these data look like?

glimpse(phila_tracts)

# Look at some central tendancies

mean(phila_tracts$pop)

median(phila_tracts$med_inc) # what's going wrong here??

median(phila_tracts$med_inc, na.rm = TRUE)

# Let's use the core dplyr "verbs" to manipulate the data and create some new data frames

just_two_columns <- phila_tracts %>%
  select(GEOID, tract)

some_new_column_names <- phila_tracts %>%
  rename(tracty_mctracterson = tract,
         unique_ID = GEOID)

# When I use the mutate command, I'm going to overwrite my existing data frame - that helps
# keep my environment nice and clean (but can also cause me issues if i'm not careful)

phila_tracts <- phila_tracts %>%
  mutate(pct_own = 100*(owner_hh/hhs),
         majority_white = ifelse(pct_wht > 50, "Majority White", "Majority Non-White"))

# Let's do some more detailed kinds of summaries using group_by

# OK, now let's get SPATIAL

# Load an sf object

phila_tracts_sf <- st_read("https://raw.githubusercontent.com/mafichman/cpln_0795/main/data/philadelphia_tracts_no_data.geojson")

# What does it look like?

glimpse(phila_tracts_sf)

phila_tracts_sf

st_crs(phila_tracts_sf)

# Let's reproject it to PA State Plane (see spatialreference.org to find the CRS)
# To keep our environment nice and neat, let's 

phila_tracts_sf %>% 
  st_transform(crs = 2272)

# do a tabular join to bring the two objects together

tracts_with_data <- left_join(phila_tracts_sf, phila_tracts, by = "NAME")

# What do we have now? Let's check out our data.

glimpse(tracts_with_data)

# Let's clean it up a bit, some of our columns got duplicated and renamed

tracts_with_data <- tracts_with_data %>%
  select(-tract.y, -GEOID.y) %>%
  rename(GEOID = GEOID.x,
         tract = tract.x)

# Let's make a histogram using the ggplot package - it's basically a "recipe" for a graphic
# You add geometries (geom), and you aestheticize data with aes() inside those elements
# Notice we use a plus sign instead of the pipe from dplyr, but the idea is the same

ggplot()+
  geom_histogram(data = tracts_with_data, 
                 aes(med_inc))

# Let's make it prettier using an onboard graphic theme from ggplot

ggplot()+
  geom_histogram(data = tracts_with_data, 
                 aes(med_inc)) +
  theme_bw()

# Let's go one step further and add some titles and style the axes

ggplot()+
  geom_histogram(data = tracts_with_data, 
                 aes(med_inc)) +
  labs(
    title = "Median Household Income, Philadelphia Census Tracts, 2020",
    subtitle = "The Average Tract's Median HH Income is appx $26,700",
    x="Dollars (not inflation adjusted)",
    y="Number of Tracts",
    caption = "Data: American Community Survey 5-year estimates")+
  theme_bw()

# Let's make a "facetted" map, comparing variables between majority owner versus majority white vs
# majority non-white tracts. Facets split data along categorical lines according to some column

ggplot()+
  geom_histogram(data = tracts_with_data, 
                 aes(med_inc)) +
  facet_wrap(~majority_white)+
  labs(
    title = "Median Household Income, Philadelphia Census Tracts, 2020",
    subtitle = "The Average Tract's Median HH Income is appx $26,700",
    x="Dollars (not inflation adjusted)",
    y="Number of Tracts",
    caption = "Data: American Community Survey 5-year estimates")+
  theme_bw()

## Challenge number 1 - make a new variable using mutate and generate a two histograms with those data
## One standalone, and one using facets

# MAKING MAPS

# Oh wait, we can use the ggplot package to make maps too!

ggplot()+
  geom_sf(data = tracts_with_data,
          aes(fill = med_inc))

# make it prettier

ggplot()+
  geom_sf(data = tracts_with_data,
          aes(fill = med_inc), color = "transparent")+
  theme_minimal()

# Let's make a new column of data on the fly and visualize it

ggplot()+
  geom_sf(data = tracts_with_data %>%
    mutate(owner_pct = 100*(owner_hh / hhs)),
  aes(fill = owner_pct)) +
  theme_minimal()

# This creates some weird tract with an erroneous number, let's filter out anything over 100%

ggplot()+
  geom_sf(data = tracts_with_data %>%
            mutate(owner_pct = 100*(owner_hh / hhs)) %>%
            filter(owner_pct <= 100),
          aes(fill = owner_pct)) +
  theme_minimal()

# This creates some weird tract with an erroneous number, let's filter out anything over 100%

ggplot()+
  geom_sf(data = tracts_with_data %>%
            mutate(owner_pct = 100*(owner_hh / hhs)) %>%
            filter(owner_pct <= 100),
          aes(fill = owner_pct)) +
  theme_minimal()

# Challenge # 2 - make 2 new map visualizations by mutating new variables.

# Challenge # 3 - if time allows:

# Try using the viridis and viridisLite packages to create some cooler color ramps with our fill aesthetics
# Google it and see what you find.

# SECOND CLASS

# Start a github account
# Clone this repo using github desktop
# Open the markdown

# Maybe move this second part to a markdown??

# Load the same data from tidycensus... load your API key

library(tidycensus)

# Load your census API key

census_api_key("e79f3706b6d61249968c6ce88794f6f556e5bf3d", overwrite = TRUE)

# Let's look at our ACS variable library

acs_variable_list <- load_variables(2020, #year
                                    "acs5", #five year ACS estimates
                                    cache = TRUE)

# What does load_variables do? Where did that come from?

??load_variables

# Philly 2020 blockgroups with population

## Set up a list of variables to grab
acs_vars <- c("B01001_001E", # ACS total Pop estimate
              "C02003_004E", # One race black
              "C02003_003E", # One race white
              "B03001_003E", # Hispanic (all)
              "B02001_005E", # AAPI
              "B11012_001E", # n Households
              "B08137_003E", # Renter hh
              "B08137_002E", # owner hh
              "B06011_001E") # Median income in past 12 months

# Use tidycensus to grab the data
# If you don't know what get_acs is, try ??get_acs
# Note that geometry = TRUE - we are asking for a shp/geojson/sf type object!

acs2020 <- get_acs(geography = "tract",
                   year = 2020,
                   variables = acs_vars,
                   geometry = TRUE,
                   state = "PA",
                   county = "Philadelphia",
                   output = "wide")

# Let's use the dplyr pipe to chain some commands together and clean our data

# Yes, this is how I created our data sets for the other classes, it was easy!

acs2020 <- acs2020 %>%
  select(GEOID, NAME, acs_vars) %>%
  rename(pop = B01001_001E,
         med_inc = B06011_001E,
         blk_tot = C02003_004E,
         wht_tot = C02003_003E,
         hsp_tot = B03001_003E,
         aapi_tot = B02001_005E,
         hhs = B11012_001E,
         renter_hh = B08137_003E,
         owner_hh = B08137_002E) %>%
  mutate(year = 2020,
         pct_wht = 100*(wht_tot/pop),
         pct_blk = 100*(blk_tot/pop),
         pct_hsp = 100*(hsp_tot/pop),
         pct_aapi = 100*(aapi_tot/pop),
         rent_pct = 100*(renter_hh / hhs))

# Load the 311 data

philly_311 <- st_read("https://raw.githubusercontent.com/mafichman/cpln_0795/main/data/philly_311.geojson")

# Check out the data, these are points.

ggplot()+
  geom_sf(data = philly_311)

# What's the CRS?

st_crs(philly_311)

# Does it match the thing we want to join it to?

st_crs(acs2020)

# Let's transform the CRS to conform to the philly_311 projection - 2272

acs2020 <- acs2020 %>%
  st_transform(crs = 2272)

# Now that everything is in the same CRS, let's look at both things together
# Let's set acs2020 to just be all black, no aes() visualization here,
# and let's set our linework to transparent.
# We can vary the aesthetics of the points to see if we can get a better looking map
# I'm going to make the points yellow, adjust the alpha (aka transparency), and fiddle
# with the "size" parameter.

ggplot()+
  geom_sf(data = acs2020,
          fill = "black", color = "transparent")+
  geom_sf(data = philly_311,
          color = "yellow", alpha = 0.2,
          size = .5)+
  theme_minimal()

# Spatial join - relating 311 calls to tracts

points_and_tracts <- st_join(philly_311, acs2020)

glimpse(points_and_tracts)

# OK, that's nice, but let's clean it up a bit so that all we are dealing with on the acs side is the GEOID
# We don't need all that other stuff - ultimately, we just need to summarize by the tract ID and then
# make a tabular join back to our tracts

points_and_tracts <- st_join(philly_311, acs2020 %>%
                               select(GEOID))

# To make a summary, we use the group_by and summarize commands. We are going to turn our point data
# into a dataframe to keep the geometry from creating some issues for us when we summarize

tract_dumping_summary <- points_and_tracts %>%
  as.data.frame() %>%
  group_by(GEOID) %>%
  summarize(n = n())

# Now we can join it back to our ACS data using a tabular join

acs2020_incidents <- left_join(acs2020, tract_dumping_summary, by = "GEOID")

# What should we do about these NA observations?
# Why did they come about?

acs2020_incidents <- acs2020_incidents %>%
  mutate(n = ifelse(is.na(n) == TRUE, 0, n))

# Let's map it

ggplot()+
  geom_sf(data = acs2020_incidents,
          aes(fill = n), color = "transparent")+
  theme_minimal()

# Let's create a column that has an area measurement

acs2020_incidents <- acs2020_incidents %>%
  mutate(area = st_area(.))

# The measurement is IN THE LINEAR UNIT OF THE PROJECTION - projections are important!
# For the record, there are 27878555.87 square feet in a square mile. Yes imperial units are annoying!
# So let's manually do a transformation - note that I convert it to numeric to get rid of that notation
# from the area column

acs2020_incidents <- acs2020_incidents %>%
  mutate(area_sqmi = as.numeric(area/27878555.87))

# Mapping and analysis workshop

# Create some new code chunks in your markdown and knit it

# Chunk 1

# Create two normalized measures of incident intensity - per capita and area

# Chunk 2 - put all the following code in this chunk

# Add some hydrology data from Tigris
# Here is how you do that. Use the area_water function from tigris, and request data
# of the class sf for Philadelphia county. This will call the data from the census spatial library
# When you have those data, make sure they are projected to 2272, if not, st_transform them
# When you "knit" your markdown, see if you can
# manipulate code chunk options including setting warning, echo, and message to false in order to
# suppress unwanted outputs.

# Chunks 3 and 4

# Now make maps of your two measures
# Add a title, subtitle and caption (with data attribution) to the map.
# Change the color ramp if possible
# Add council districts on top with the fill set to transparent

# Add some annotation - what are your observations regarding the spatial process of these 311 calls?


# make a markdown from a template, grab this repo from github, make a change to your own repo and push it.